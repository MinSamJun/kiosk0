# kiosk0

사용하는 api들과 설명

1. 관리자 - 옵션추가
   POST http://0.0.0.0:3000/api/option/option
{
  "passwrod":"----",
  "option_name":"디저트용",
  "extra_price":"10000",
  "shot_price":"0",
  "hot_price":"0"
}

{
  "passwrod":"----",
  "option_name":"커피용",
  "extra_price":"2000",
  "shot_price":"300",
  "hot_price":"0"
}

위와같이 옵션을 음료용과 케이크용등으로 따로 만들 수 있다.
과제 요구과 다르게 구현한 부분과 이유
  1. 과제에서는 옵션의 가격이 0원일 경우 선택이 불가능하게 만들라고 했지만, 가격이 0원이어도 가능하게했다.
     왜냐하면, 커피의 경우 기본적으로 따뜻하게 나오기 때문에, 핫이라고 돈이 더 나가지 않기 때문이다.

2. 관리자 - 아이템 생성
   POST http://0.0.0.0:3000/api/item/Item
{
  "name": "메뉴1",
  "price":"1000",
  "type":"food",
  "option_id":"1",
  "passwrod":"----"
}

기본 아이템 갯수는 0개로 만들어지게 설정해놨다.
갯수를 추가하고 싶으면 발주를 넣고 완료하거나, 수정에서 임의의 값을 넣을 수 있다.
아직 재고가 없지만 미리 메뉴만 추가할 수 도 있고, 반대로 재고가 있는 상태에서도 추가할 수 있기 때문이다.
카테고리명을 잘못 입력하면 "카테고리 명은 coffee , juice , food 중 하나입니다." 라는 경고 메시지를 반환한다.

3. 관리자 - 아이템 카테고리별 조회
   GET http://0.0.0.0:3000/api/Item/Item
{ 
  "orderFilter" :"all",
  "orderSort":"name",
  "passwrod":"----"
}

필터가 all 일 경우 모든 카테고리, coffee , juice , food는 각각의 카테고리를 조회한다.
잘못 입력시 "카테고리 명은 all, coffee , juice , food 중 하나입니다."를 반환한다.
과제 요구와 다르게 구현한 부분과 이유
  1. 과제에서는 재구성 된 리스트를 사용자에게 반환하라고 하였지만 그러지 않았다.
     여기서는 백만 구현했지만, 실제 키오스크는 프론트도 함께 있으며, 그때 값을 입력 받는게 아니라 선택시킬 수 있기 때문이다.
     위의 옵션추가와 마찬가지로, 0원이어도 보여줄 옵션이 있기 때문에, 단순히 가격이 0원이냐 아니냐로 보여주는걸 정할 수 없기 때문에,
     프론트를 만들 때 정할것이다.
     예) 커피에 hot은 가능하지만 , 케이크에는 hot이 말이 안된다.

4. 관리자 - 아이템 정보 수정
   PATCH http://0.0.0.0:3000/api/item/update
{
  "name":"메뉴1",
  "nameToUpdate" : "메뉴12",
  "price":"15000",
  "type":"food",
  "amount":"1000",
  "passwrod":"15228016"
}

nameToUpdate 가 비어있을 경우에는 기존의 이름이 유지된다.
price 는 물건 자체의 가격이며, 이후 유저가 주문하는 과정에서 옵션들의 가격과 합산된다.

5. 관리자 - 아이템 삭제 1
   GET http://0.0.0.0:3000/api/item/amount
{
  "name" : "메뉴12",
  "passwrod":"----"
}

메뉴의 이름을 입력하면, 메뉴의 ID와 잔량을 알려준다.
아래의 아이템 삭제와 연동하기 위해 만든 기능

6. 관리자 - 아이템 삭제 2
   DELETE http://0.0.0.0:3000/api/item/delete/:item_id
 {
   "passwrod":"----"
 }

   잔량 여부는 아이템 삭제 1에서 확인 했기 때문에 여기서는 삭제할 ID와 비밀번호만 입력하면 품목을 삭제한다.
   과제 요구와 다르게 구현한 부분과 이유
   1. 프론트에서 진짜로 삭제할지 입력을 받는 부분
      프론트를 구현하지 않으니 어떻게 해야할지 감이 잡히지 않았다.
      그래서 하나의 매서드로 해도 될 것을 두 개로 나누었으며, 나중에 프론트를 만들게 된다면 아이템 삭제 1의 값이 리턴이 된다면,
      프론트에서는 남은 갯수와 아이디를 알려주고, "예" 버튼을 누르면 아이템삭제 2 에 자동으로 삭제할 아이템의 ID가 들어가도록 만들것이다.

7. 관리자 - 아이템 발주 넣기
   POST http://0.0.0.0:3000/api/itemOrder/order/:item_id
 {
   "amount":"5"
 }

아이템의 발주를 넣을 수 있는 기능

8. 관리자 - 아이템 발주 수정
   PATCH http://0.0.0.0:3000/api/itemOrder/order/:item_id
{ 
  "status" : "COMPLETED"
}

ID로 아이템 발주의 상태를 수정할 수 있는 기능

발주 상태를 적절히 입력하지 않으면 "적절한 발주 상태를 입력해주세요. (ORDERED, PENDING, COMPLETED, CANCELED)"를 반환한다.

현재 발주상태와 바꾸려는 발주 상태가 같으면 "발주를 같은 상태로 바꿀 수 없습니다." 를 반환한다.

현재 발주상태가 COMPLETED이며 다른 것으로 바꾸려고 할 때, 발주량보다 현재 재고가 적다면 "재고가 부족하여 반송할 수 없습니다." 를 반환한다.

그 외의 변화는 자유롭다.


9. 고객 - 주문시작
    POST http://0.0.0.0:3000/api/orderCustomer/order/start

   고객이 주문하기를 누르면 시작되는 API order_customers 테이블에 주문 ID를 생성한다.

10. 고객 - 주문
    POST http://0.0.0.0:3000/api/orderCustomer/order/:item_id
{ 
  "amount":"10",
  "extra_TF":true,
  "shot_amount":"3",
  "hot_TF":true
}

    고객이 개개의 아이템의 수량과 옵션을 고를때마다 order_customers_id 테이블에 해당 주문의 정보를 생성한다.
    각각의 레코드는 order_customers_id 라는 필드를 가지며, 값은 order_customers의 id중 가장 높은 값이다.

11. 관리자 - 주문 완료
    PATCH http://0.0.0.0:3000/api/orderCustomer/order/:order_id

{
  "satus" : "true"
}

주문한 상품이 모두 나와서 고객에게 서빙 될 때 수정하는 api

9~11의 과정은 트랜잭션으로 관리된다.

새로운 주문을 받을때마다 9~11이 반복된다.


이상 주요기능들의 설명이었습니다.
